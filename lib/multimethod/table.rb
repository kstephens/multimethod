module Multimethod
  class Table

    @@instance = nil
    def self.instance
      # THREAD CRITICAL BEGIN
      @@instance ||= self.new
      # TRREAD CRITICAL END
    end

    @@hook_var = :@@__multimethods
 
    def initialize(*opts)
      @method = { }

      # Type name lookup cache
      @name_to_object = { }
    end


    @@match_def = /^\s*def\s+(\w+)([(](.*)[)])?/
    # Interface to Multimethod::Module mixin multimethod
    def install_method(mod, body, file = nil, line = nil)
      name = nil
      params = nil

      # Parse first line.
      if md = body.match(@@match_def)
        name = md[1]
        params = md[3] || ''
      else
        raise("Cannot determine name(params) from body")
      end
        
      # Get our Multimethod for this
      mm = lookup_multimethod(name)
      mm.install_dispatch(mod)
      m = mm.new_method(mod, params)
 
      # Evaluate our method.
      new_body = body.clone
      new_body.sub!(@@match_def, m.to_ruby)

      # if m.restarg
      #   $stderr.puts "install_method(#{mod}) => #{m.to_ruby}:\n#{new_body}"
      # end

      file ||= __FILE__; line ||= __LINE__
      m.file = file; m.line = line
      mod.module_eval(new_body, file || __FILE__, line || __LINE__)
    end


    def lookup_multimethod(name)
      name = name.to_s

      # THREAD CRITICAL BEGIN
      unless mm = @method[name]
        mm = Multimethod.new(name)
        mm.table = self
        @method[name] = mm
      end
      # THREAD CRITICAL END

      mm
    end


    # Interface to code generated by #install_dispatch.
    def dispatch(name, rcvr, args)
      unless mm = @method[name]
        raise NameError, 'No method for multmethod #{name}' unless mm
      end
      mm.dispatch(rcvr, args)
    end


    #################################################
    # Support
    #

    def name_to_object(name, scope = nil, file = nil, line = nil)
      scope ||= Kernel
      # THREAD CRITICAL BEGIN
      unless x = (@name_to_object[scope] ||= { })[name]
        # $stderr.puts " name_to_object(#{name.inspect}) in #{scope}"
        x = 
          @name_to_object[scope][name] = 
          scope.module_eval(name, file || __FILE__, line || __LINE__)
      end
      # THREAD CRITICAL END

      x
    end

  end # class

end # module


