module Multimethod
  class Table

    @@instance = nil
    def self.instance
      # THREAD CRITICAL BEGIN
      @@instance ||= self.new
      # TRREAD CRITICAL END
    end

    @@hook_var = :@@__multimethods
 
    def initialize(*opts)
      @method = { }

      # Type name lookup cache
      @name_to_object = { }
    end


    @@match_def = /^\s*def\s+(\w+)([(](.*)[)])?/
    # Interface to Multimethod::Module mixin multimethod
    def install_method(mod, body, file = nil, line = nil)
      file ||= __FILE__
      line ||= __LINE__
      verbose = nil
      #if body =~ /def bar\(x, y\)/
      #  verbose = 1
      #end

      # Parse the signature from the method body
      signature = Signature.new
      signature.mod = mod
      signature.verbose = verbose
      signature.file = file
      signature.line = line
      new_body = signature.scan_string(body.clone)
      
      # Get our Multimethod for this
      mm = lookup_multimethod(signature.name)
      mm.install_dispatch(mod)
      m = mm.new_method_from_signature(signature)
      m.file = file
      m.line = line

      # Replace the multimethod signature with a plain Ruby signature.
      new_body = m.to_ruby_def + new_body

      #if true || m.signature.restarg
      #   $stderr.puts "install_method(#{mod}) => #{m.to_ruby_signature}:\n#{new_body}"
      #end

      # Evaluate the new method body.     
      mod.module_eval(new_body, file, line)
    end


    def lookup_multimethod(name)
      name = name.to_s

      # THREAD CRITICAL BEGIN
      unless mm = @method[name]
        mm = Multimethod.new(name)
        mm.table = self
        @method[name] = mm
      end
      # THREAD CRITICAL END

      mm
    end


    # Interface to code generated by #install_dispatch.
    def dispatch(name, rcvr, args)
      unless mm = @method[name]
        raise NameError, 'No method for multmethod #{name}' unless mm
      end
      mm.dispatch(rcvr, args)
    end


    #################################################
    # Support
    #

    def name_to_object(name, scope = nil, file = nil, line = nil)
      scope ||= Kernel
      # THREAD CRITICAL BEGIN
      unless x = (@name_to_object[scope] ||= { })[name]
        # $stderr.puts " name_to_object(#{name.inspect}) in #{scope}"
        x = 
          @name_to_object[scope][name] = 
          scope.module_eval(name, file || __FILE__, line || __LINE__)
      end
      # THREAD CRITICAL END

      x
    end

  end # class

end # module


